library(shiny)
library(tmap)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(viridis)

# ====================================================================
# CONFIGURATION ET CHARGEMENT DES DONN√âES STATIQUES
# ====================================================================

base_path <- getwd()
output_dir <- file.path(base_path, "outputs")

# Cr√©ation du dossier de sortie
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Dossier de sortie cr√©√© :", output_dir, "\n")
}

# --- Importation des donn√©es ---
tryCatch({
  # H√¥pitaux
  HPT_shp <- file.path(base_path, "data/data2/202303-osm2igeo-cameroun-shp-wgs84-4326/202303_OSM2IGEO_CAMEROUN_SHP_WGS84_4326/I_OSM_ZONE_ACTIVITE/PAI_SANTE.shp")
  hopital <- st_read(HPT_shp, quiet = TRUE)
  
  # Limites administratives
  CMR_shp_3 <- file.path(base_path, "data/data2/shapefiles_limites_administratives_GADM_Cameroun/gadm41_CMR_3.shp")
  cameroun_limite_3 <- st_read(CMR_shp_3, quiet = TRUE)
  
  # Localit√©s
  place_shp <- file.path(base_path, "data/data2/cameroon-251116-free.shp/gis_osm_places_free_1.shp")
  place <- st_read(place_shp, quiet = TRUE)
  fclass_display <- c("city", "town", "village", "hamlet", "suburb", "locality")
  place <- place %>% filter(fclass %in% fclass_display)
  
  # Population
  raster_file_path <- file.path(base_path, "data/data2/worldpop/cmr_pop_2025_CN_100m_R2024B_v1.tif")
  worldpop <- rast(raster_file_path)
  
  cat("Toutes les donn√©es ont √©t√© charg√©es avec succ√®s.\n")
  
}, error = function(e) {
  stop("Erreur lors du chargement des donn√©es : ", e$message)
})

# --- Projection vers CRS m√©trique ---
CRS_METRIQUE_EPSG <- "EPSG:32633"

regions_dep_arr_projete <- st_transform(cameroun_limite_3, crs = CRS_METRIQUE_EPSG)
hopital_projete <- st_transform(hopital, crs = CRS_METRIQUE_EPSG)
place_projete <- st_transform(place, crs = CRS_METRIQUE_EPSG)

cat("Projection du raster WorldPop...\n")
worldpop_projete <- project(worldpop, CRS_METRIQUE_EPSG)
cat("Projection termin√©e.\n")

# --- Enrichissement des donn√©es ---

# 1. Nombre d'h√¥pitaux par r√©gion
hopitaux_par_region <- st_join(
  hopital_projete,
  regions_dep_arr_projete,
  join = st_intersects,
  left = FALSE
) %>%
  st_drop_geometry() %>%
  group_by(NAME_1) %>%
  tally(name = "Nb_Hopitaux") %>%
  ungroup()

# 2. R√©gions avec statistiques
regions_interactives <- regions_dep_arr_projete %>%
  group_by(NAME_1) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup() %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  mutate(Nb_Hopitaux = replace_na(Nb_Hopitaux, 0)) %>%
  rename(
    R√©gion = NAME_1,
    `Nombre d'h√¥pitaux dans la r√©gion` = Nb_Hopitaux
  ) %>%
  select(R√©gion, `Nombre d'h√¥pitaux dans la r√©gion`) %>%
  mutate(region_id = as.character(seq_len(nrow(.))))

# 3. H√¥pitaux enrichis
hopital_projete_enriched <- hopital_projete %>%
  mutate(hopital_id = as.character(seq_len(nrow(.)))) %>%
  st_join(
    regions_dep_arr_projete %>% select(NAME_1, NAME_2, NAME_3),
    join = st_intersects,
    left = TRUE
  ) %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  rename(
    Nom_Hopital = NOM,
    R√©gion = NAME_1,
    D√©partement = NAME_2,
    Arrondissement = NAME_3,
    `Nombre d'h√¥pitaux dans la r√©gion` = Nb_Hopitaux
  ) %>%
  mutate(
    popup_fix = "",
    `Nombre d'h√¥pitaux dans la r√©gion` = replace_na(`Nombre d'h√¥pitaux dans la r√©gion`, 0)
  ) %>%
  select(hopital_id, popup_fix, Nom_Hopital, Arrondissement, 
         D√©partement, R√©gion, `Nombre d'h√¥pitaux dans la r√©gion`)

# 4. Localit√©s avec distance au plus proche h√¥pital
place_projete_enriched <- place_projete %>%
  mutate(place_id = as.character(seq_len(nrow(.)))) %>%
  mutate(
    nearest_hopital_index = st_nearest_feature(., hopital_projete),
    nearest_hopital_name = hopital_projete$NOM[nearest_hopital_index],
    distance_to_nearest_hopital_m = st_distance(
      ., 
      hopital_projete[nearest_hopital_index, ], 
      by_element = TRUE
    ),
    `Distance (km)` = round(as.numeric(distance_to_nearest_hopital_m) / 1000, 2)
  ) %>%
  rename(
    `Type de localit√©` = fclass,
    Nom = name,
    `H√¥pital le plus proche` = nearest_hopital_name
  ) %>%
  select(place_id, Nom, `Type de localit√©`, `H√¥pital le plus proche`, `Distance (km)`)

# ====================================================================
# INTERFACE UTILISATEUR
# ====================================================================

ui <- fluidPage(
  titlePanel("Carte interactive de couverture sanitaire du Cameroun"),
  
  sidebarLayout(
    sidebarPanel(
      width = 3,
      
      sliderInput("buffer_dist", 
                  "Distance de tampon (km) :",
                  min = 0, max = 100, value = 5, step = 1),
      hr(),
      
      checkboxGroupInput("fclass_select",
                         "Afficher les localit√©s de type :",
                         choices = fclass_display,
                         selected = c("city", "town", "village")),
      hr(),
      
      tags$h4(tags$b("Analyse d'Accessibilit√©")),
      tags$p("Cliquez sur un h√¥pital (point rouge)", style = "font-style: italic; color: #666;"),
      verbatimTextOutput("hospital_analysis"),
      hr(),
      
      tags$h4(tags$b("Proximit√© Sanitaire")),
      tags$p("Cliquez sur une localit√© (point bleu)", style = "font-style: italic; color: #666;"),
      verbatimTextOutput("place_analysis"),
      
      tags$hr(),
      tags$p("Source : OSM, GADM, WorldPop", 
             style = "font-size: 10px; color: grey; margin-top: 20px;")
    ),
    
    mainPanel(
      width = 9,
      tmapOutput("interactive_map", height = "800px")
    )
  )
)

# ====================================================================
# LOGIQUE SERVEUR
# ====================================================================

server <- function(input, output, session) {
  
  tmap_mode("view")
  
  # Valeurs r√©actives
  rv_analysis <- reactiveValues(
    hospital_data = "Cliquez sur un h√¥pital (point rouge) pour analyser le tampon.",
    place_data = "Cliquez sur une localit√© (point bleu) pour trouver l'h√¥pital le plus proche.",
    clicked_hospital_id = NULL,
    clicked_place_id = NULL
  )
  
  # Calcul r√©actif du tampon
  buffer_a_afficher <- reactive({
    req(input$buffer_dist)
    dist_m <- input$buffer_dist * 1000
    
    if (dist_m > 0) {
      return(st_buffer(hopital_projete, dist = dist_m))
    } else {
      return(st_sfc(st_polygon(), crs = CRS_METRIQUE_EPSG))
    }
  })
  
  # Gestion des clics sur la carte
  observeEvent(input$interactive_map_shape_click, {
    click_data <- input$interactive_map_shape_click
    
    if (!is.null(click_data$group)) {
      if (click_data$group == "H√¥pitaux Localisation") {
        rv_analysis$clicked_hospital_id <- click_data$id
        rv_analysis$clicked_place_id <- NULL
      } else if (click_data$group == "Localit√©s") {
        rv_analysis$clicked_place_id <- click_data$id
        rv_analysis$clicked_hospital_id <- NULL
      }
    }
  })
  
  # Analyse du clic sur un h√¥pital
  observeEvent(rv_analysis$clicked_hospital_id, {
    hospital_id_clicked <- rv_analysis$clicked_hospital_id
    
    if (is.null(hospital_id_clicked) || hospital_id_clicked == "") return()
    
    clicked_hopital <- hopital_projete_enriched %>%
      filter(hopital_id == hospital_id_clicked)
    
    if (nrow(clicked_hopital) == 0) return()
    
    dist_m <- input$buffer_dist * 1000
    
    if (dist_m > 0) {
      buffer_clicked <- st_buffer(clicked_hopital, dist = dist_m)
      
      # Extraction de la population
      total_pop_in_buffer <- tryCatch({
        population_values <- extract(worldpop_projete, buffer_clicked, 
                                     fun = sum, na.rm = TRUE)
        
        if (!is.null(population_values) && ncol(population_values) >= 2) {
          pop <- population_values[[2]][1]
          if (is.na(pop)) 0 else pop
        } else {
          0
        }
      }, error = function(e) {
        cat("Erreur extraction population:", e$message, "\n")
        0
      })
      
      # Comptage des localit√©s
      localities_in_buffer <- st_filter(place_projete, buffer_clicked, 
                                        .predicate = st_intersects)
      
      locality_counts <- localities_in_buffer %>%
        st_drop_geometry() %>%
        group_by(fclass) %>%
        tally(name = "Count") %>%
        arrange(desc(Count))
      
      locality_text <- if (nrow(locality_counts) > 0) {
        paste(locality_counts$fclass, ":", locality_counts$Count, collapse = "\n")
      } else {
        "Aucune localit√© trouv√©e dans le tampon."
      }
      
      rv_analysis$hospital_data <- paste(
        "H√¥pital cliqu√© :", clicked_hopital$Nom_Hopital, "\n",
        "Distance de Tampon :", input$buffer_dist, "km\n",
        "--------------------------------------\n",
        "Population estim√©e dans le tampon :\n",
        format(round(total_pop_in_buffer), big.mark = " ", scientific = FALSE), "\n",
        "--------------------------------------\n",
        "Localit√©s incluses dans le tampon (par type) :\n",
        locality_text
      )
    } else {
      rv_analysis$hospital_data <- paste(
        "H√¥pital cliqu√© :", clicked_hopital$Nom_Hopital, "\n",
        "Distance de Tampon : 0 km\n",
        "--------------------------------------\n",
        "Augmentez la distance du tampon pour effectuer l'analyse."
      )
    }
  })
  
  # Analyse du clic sur une localit√©
  observeEvent(rv_analysis$clicked_place_id, {
    place_id_clicked <- rv_analysis$clicked_place_id
    
    if (is.null(place_id_clicked) || place_id_clicked == "") return()
    
    clicked_place <- place_projete_enriched %>%
      filter(place_id == place_id_clicked)
    
    if (nrow(clicked_place) > 0) {
      rv_analysis$place_data <- paste(
        "Localit√© cliqu√©e :", clicked_place$Nom, "\n",
        "Type :", clicked_place$`Type de localit√©`, "\n",
        "--------------------------------------\n",
        "H√¥pital le plus proche :", clicked_place$`H√¥pital le plus proche`, "\n",
        "Distance :", clicked_place$`Distance (km)`, "km"
      )
    }
  })
  
  # Sorties textuelles
  output$hospital_analysis <- renderPrint({
    cat(rv_analysis$hospital_data)
  })
  
  output$place_analysis <- renderPrint({
    cat(rv_analysis$place_data)
  })
  
  # Rendu de la carte
  output$interactive_map <- renderTmap({
    tampon_a_afficher <- buffer_a_afficher()
    
    localites_filtrees <- place_projete_enriched %>%
      filter(`Type de localit√©` %in% input$fclass_select)
    
    fclass_levels <- unique(localites_filtrees$`Type de localit√©`)
    dot_palette <- if (length(fclass_levels) > 0) {
      setNames(viridis(length(fclass_levels), option = "C"), fclass_levels)
    } else {
      c("default" = "blue")
    }
    
    tm_basemap(server = "OpenStreetMap") +
      
      # R√©gions administratives
      tm_shape(regions_interactives, name = "R√©gions administratives",
               id = "region_id", popup.vars = TRUE) +
      tm_borders(col = "grey10", lwd = 2, alpha = 0.05) +
      tm_fill(col = NA, alpha = 0) +
      
      # Zone d'acc√®s (tampon)
      tm_shape(tampon_a_afficher, 
               name = paste0("Zone d'Acc√®s (", input$buffer_dist, " km)")) +
      tm_fill(col = "lightcoral", alpha = 0.4) +
      tm_borders(col = "darkred", lwd = 0.5, alpha = 0.6) +
      
      # Localit√©s
      tm_shape(localites_filtrees, name = "Localit√©s") +
      tm_dots(
        col = "Type de localit√©",
        id = "place_id",
        palette = dot_palette,
        shape = 16,
        size = 0.1,
        popup.vars = c(
          "Nom de la Localit√©" = "Nom",
          "Type" = "Type de localit√©",
          "H√¥pital le plus proche" = "H√¥pital le plus proche",
          "Distance (km)" = "Distance (km)"
        )
      ) +
      
      # H√¥pitaux
      tm_shape(hopital_projete_enriched, name = "H√¥pitaux Localisation") +
      tm_dots(
        col = "darkred",
        id = "hopital_id",
        shape = 10,
        size = 0.15,
        popup.vars = c(
          " " = "popup_fix",
          "Nom de l'H√¥pital" = "Nom_Hopital",
          "Arrondissement" = "Arrondissement",
          "D√©partement" = "D√©partement",
          "R√©gion" = "R√©gion",
          "Nb d'h√¥pitaux dans la r√©gion" = "Nombre d'h√¥pitaux dans la r√©gion"
        )
      ) +
      
      # Mise en page
      tm_layout(
        title = "R√©partition des h√¥pitaux au Cameroun",
        title.position = c("center", "top"),
        title.size = 1.2,
        legend.outside = TRUE,
        legend.text.size = 0.8,
        frame = FALSE
      )
  })
}

# ====================================================================
# LANCEMENT DE L'APPLICATION
# ====================================================================

shinyApp(ui = ui, server = server)











































































library(shiny)
library(leaflet)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(viridis)

# ====================================================================
# CONFIGURATION ET CHARGEMENT DES DONN√âES STATIQUES
# ====================================================================

base_path <- getwd()
output_dir <- file.path(base_path, "outputs")

# Cr√©ation du dossier de sortie
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Dossier de sortie cr√©√© :", output_dir, "\n")
}

# --- Importation des donn√©es ---
tryCatch({
  # H√¥pitaux
  HPT_shp <- file.path(base_path, "data/data2/202303-osm2igeo-cameroun-shp-wgs84-4326/202303_OSM2IGEO_CAMEROUN_SHP_WGS84_4326/I_OSM_ZONE_ACTIVITE/PAI_SANTE.shp")
  hopital <- st_read(HPT_shp, quiet = TRUE)
  
  # Limites administratives
  CMR_shp_3 <- file.path(base_path, "data/data2/shapefiles_limites_administratives_GADM_Cameroun/gadm41_CMR_3.shp")
  cameroun_limite_3 <- st_read(CMR_shp_3, quiet = TRUE)
  
  # Localit√©s
  place_shp <- file.path(base_path, "data/data2/cameroon-251116-free.shp/gis_osm_places_free_1.shp")
  place <- st_read(place_shp, quiet = TRUE)
  fclass_display <- c("city", "town", "village", "hamlet", "suburb", "locality")
  place <- place %>% filter(fclass %in% fclass_display)
  
  # Population
  raster_file_path <- file.path(base_path, "data/data2/worldpop/cmr_pop_2025_CN_100m_R2024B_v1.tif")
  worldpop <- rast(raster_file_path)
  
  cat("Toutes les donn√©es ont √©t√© charg√©es avec succ√®s.\n")
  
}, error = function(e) {
  stop("Erreur lors du chargement des donn√©es : ", e$message)
})

# --- Projection vers CRS m√©trique pour les calculs ---
CRS_METRIQUE_EPSG <- "EPSG:32633"

regions_dep_arr_projete <- st_transform(cameroun_limite_3, crs = CRS_METRIQUE_EPSG)
hopital_projete <- st_transform(hopital, crs = CRS_METRIQUE_EPSG)
place_projete <- st_transform(place, crs = CRS_METRIQUE_EPSG)

cat("Projection du raster WorldPop...\n")
worldpop_projete <- project(worldpop, CRS_METRIQUE_EPSG)
cat("Projection termin√©e.\n")

# --- Enrichissement des donn√©es ---

# 1. Nombre d'h√¥pitaux par r√©gion
hopitaux_par_region <- st_join(
  hopital_projete,
  regions_dep_arr_projete,
  join = st_intersects,
  left = FALSE
) %>%
  st_drop_geometry() %>%
  group_by(NAME_1) %>%
  tally(name = "Nb_Hopitaux") %>%
  ungroup()

# 2. Population par r√©gion
population_par_region <- tryCatch({
  regions_union <- regions_dep_arr_projete %>%
    group_by(NAME_1) %>%
    summarise(geometry = st_union(geometry)) %>%
    ungroup()
  
  # Extraire les valeurs de population pour chaque r√©gion
  pop_extract <- extract(worldpop_projete, regions_union, fun = sum, na.rm = TRUE)
  
  regions_union %>%
    mutate(Population = ifelse(!is.na(pop_extract[[2]]), pop_extract[[2]], 0)) %>%
    st_drop_geometry() %>%
    select(NAME_1, Population)
}, error = function(e) {
  cat("Erreur calcul population par r√©gion:", e$message, "\n")
  # Retourner des donn√©es par d√©faut
  regions_dep_arr_projete %>%
    st_drop_geometry() %>%
    group_by(NAME_1) %>%
    summarise(Population = 0) %>%
    ungroup()
})

# 3. R√©gions avec statistiques compl√®tes
regions_interactives <- regions_dep_arr_projete %>%
  group_by(NAME_1) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup() %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  left_join(population_par_region, by = "NAME_1") %>%
  mutate(
    Nb_Hopitaux = replace_na(Nb_Hopitaux, 0),
    Population = replace_na(Population, 0)
  ) %>%
  rename(
    R√©gion = NAME_1,
    `Nombre d'h√¥pitaux dans la r√©gion` = Nb_Hopitaux,
    `Population de la r√©gion` = Population
  ) %>%
  select(R√©gion, `Nombre d'h√¥pitaux dans la r√©gion`, `Population de la r√©gion`)

# 4. H√¥pitaux enrichis
hopital_projete_enriched <- hopital_projete %>%
  mutate(hopital_id = as.character(seq_len(nrow(.)))) %>%
  st_join(
    regions_dep_arr_projete %>% select(NAME_1, NAME_2, NAME_3),
    join = st_intersects,
    left = TRUE
  ) %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  left_join(population_par_region, by = "NAME_1") %>%
  rename(
    Nom_Hopital = NOM,
    R√©gion = NAME_1,
    D√©partement = NAME_2,
    Arrondissement = NAME_3,
    `Nombre d'h√¥pitaux dans la r√©gion` = Nb_Hopitaux,
    `Population de la r√©gion` = Population
  ) %>%
  mutate(
    `Nombre d'h√¥pitaux dans la r√©gion` = replace_na(`Nombre d'h√¥pitaux dans la r√©gion`, 0),
    `Population de la r√©gion` = replace_na(`Population de la r√©gion`, 0)
  ) %>%
  select(hopital_id, Nom_Hopital, Arrondissement, 
         D√©partement, R√©gion, `Nombre d'h√¥pitaux dans la r√©gion`, `Population de la r√©gion`)

# 5. Localit√©s avec distance au plus proche h√¥pital
place_projete_enriched <- place_projete %>%
  mutate(place_id = as.character(seq_len(nrow(.)))) %>%
  mutate(
    nearest_hopital_index = st_nearest_feature(., hopital_projete),
    nearest_hopital_name = hopital_projete$NOM[nearest_hopital_index],
    distance_to_nearest_hopital_m = st_distance(
      ., 
      hopital_projete[nearest_hopital_index, ], 
      by_element = TRUE
    ),
    `Distance (km)` = round(as.numeric(distance_to_nearest_hopital_m) / 1000, 2)
  ) %>%
  rename(
    `Type de localit√©` = fclass,
    Nom = name,
    `H√¥pital le plus proche` = nearest_hopital_name
  ) %>%
  select(place_id, Nom, `Type de localit√©`, `H√¥pital le plus proche`, `Distance (km)`)

# Conversion en WGS84 pour leaflet
regions_wgs84 <- st_transform(regions_interactives, 4326)
hopitaux_wgs84 <- st_transform(hopital_projete_enriched, 4326)
localites_wgs84 <- st_transform(place_projete_enriched, 4326)

# Debug: V√©rifier les donn√©es
cat("=== DEBUG INFORMATION ===\n")
cat("Nombre d'h√¥pitaux:", nrow(hopitaux_wgs84), "\n")
cat("Nombre de localit√©s:", nrow(localites_wgs84), "\n")
cat("Nombre de r√©gions:", nrow(regions_wgs84), "\n")
cat("Population totale estim√©e:", sum(population_par_region$Population, na.rm = TRUE), "\n")
cat("=======================\n")

# ====================================================================
# INTERFACE UTILISATEUR
# ====================================================================

ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .sidebar-panel { 
        background-color: #f8f9fa; 
        padding: 15px;
        border-radius: 5px;
        height: 800px;
        overflow-y: auto;
      }
      .main-panel { 
        padding-left: 20px;
      }
      .analysis-output {
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        white-space: pre-wrap;
        max-height: 200px;
        overflow-y: auto;
      }
    "))
  ),
  
  titlePanel("üè• Carte Interactive de Couverture Sanitaire du Cameroun"),
  
  sidebarLayout(
    sidebarPanel(
      width = 3,
      class = "sidebar-panel",
      
      h4("üéØ Param√®tres d'Analyse"),
      sliderInput("buffer_dist", 
                  "Distance de tampon (km) :",
                  min = 0, max = 100, value = 10, step = 5),
      hr(),
      
      h4("üèòÔ∏è Filtrage des Localit√©s"),
      checkboxGroupInput("fclass_select",
                         "Afficher les localit√©s de type :",
                         choices = fclass_display,
                         selected = c("city", "town", "village")),
      hr(),
      
      h4("üìä Analyse d'Accessibilit√©"),
      tags$p("Cliquez sur un h√¥pital (point rouge) pour analyser le tampon", 
             style = "font-style: italic; color: #666; font-size: 12px;"),
      div(class = "analysis-output",
          verbatimTextOutput("hospital_analysis")
      ),
      
      h4("üìç Proximit√© Sanitaire"),
      tags$p("Cliquez sur une localit√© (point color√©) pour trouver l'h√¥pital le plus proche", 
             style = "font-style: italic; color: #666; font-size: 12px;"),
      div(class = "analysis-output",
          verbatimTextOutput("place_analysis")
      ),
      
      h4("üó∫Ô∏è Information R√©gionale"),
      tags$p("Cliquez sur une r√©gion ou un espace vide de la carte", 
             style = "font-style: italic; color: #666; font-size: 12px;"),
      div(class = "analysis-output",
          verbatimTextOutput("region_analysis")
      ),
      
      tags$hr(),
      tags$p("üìö Sources : OpenStreetMap, GADM, WorldPop (2025)", 
             style = "font-size: 10px; color: grey; margin-top: 20px; text-align: center;")
    ),
    
    mainPanel(
      width = 9,
      class = "main-panel",
      leafletOutput("interactive_map", height = "800px")
    )
  )
)

# ====================================================================
# LOGIQUE SERVEUR
# ====================================================================

server <- function(input, output, session) {
  
  # Valeurs r√©actives
  rv_analysis <- reactiveValues(
    hospital_data = "Cliquez sur un h√¥pital (point rouge) pour analyser le tampon.",
    place_data = "Cliquez sur une localit√© (point color√©) pour trouver l'h√¥pital le plus proche.",
    region_data = "Cliquez sur une r√©gion ou un espace vide de la carte pour obtenir les informations r√©gionales.",
    clicked_hospital_id = NULL,
    clicked_place_id = NULL,
    clicked_region = NULL,
    current_buffers = NULL
  )
  
  # Fonction pour extraire la population d'une zone
  extract_population <- function(zone_sf) {
    tryCatch({
      # Convertir en CRS m√©trique pour l'extraction
      zone_metric <- st_transform(zone_sf, CRS_METRIQUE_EPSG)
      
      # Extraire les valeurs de population
      pop_values <- extract(worldpop_projete, zone_metric, fun = sum, na.rm = TRUE)
      
      if (!is.null(pop_values) && ncol(pop_values) >= 2 && !is.na(pop_values[[2]][1])) {
        return(pop_values[[2]][1])
      } else {
        return(0)
      }
    }, error = function(e) {
      cat("Erreur extraction population:", e$message, "\n")
      return(0)
    })
  }
  
  # Calcul r√©actif du tampon
  buffer_a_afficher <- reactive({
    req(input$buffer_dist)
    dist_m <- input$buffer_dist * 1000
    
    if (dist_m > 0) {
      buffers <- st_buffer(hopital_projete, dist = dist_m)
      buffers_wgs84 <- st_transform(buffers, 4326)
      return(buffers_wgs84)
    } else {
      return(NULL)
    }
  })
  
  # Carte Leaflet principale - VERSION SIMPLIFI√âE
  output$interactive_map <- renderLeaflet({
    # Palette pour les types de localit√©s
    palette_localites <- colorFactor(
      viridis_pal(option = "C")(length(fclass_display)),
      domain = fclass_display
    )
    
    # Palette pour les r√©gions
    population_values <- regions_wgs84$`Population de la r√©gion`
    palette_regions <- colorNumeric("Blues", domain = population_values, na.color = "transparent")
    
    # Cr√©er des labels pour les h√¥pitaux
    hopital_labels <- sprintf(
      "<strong>üè• %s</strong><br/>üìç R√©gion: %s<br/>üèõÔ∏è D√©partement: %s<br/>üë• Population r√©gionale: %s",
      hopitaux_wgs84$Nom_Hopital,
      ifelse(is.na(hopitaux_wgs84$R√©gion), "Non sp√©cifi√©", hopitaux_wgs84$R√©gion),
      ifelse(is.na(hopitaux_wgs84$D√©partement), "Non sp√©cifi√©", hopitaux_wgs84$D√©partement),
      format(round(hopitaux_wgs84$`Population de la r√©gion`), big.mark = " ", scientific = FALSE)
    ) %>% lapply(htmltools::HTML)
    
    # Cr√©er des labels pour les r√©gions
    region_labels <- sprintf(
      "<strong>üó∫Ô∏è %s</strong><br/>üë• Population: %s habitants<br/>üè• H√¥pitaux: %s",
      regions_wgs84$R√©gion,
      format(round(regions_wgs84$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
      regions_wgs84$`Nombre d'h√¥pitaux dans la r√©gion`
    ) %>% lapply(htmltools::HTML)
    
    # Cr√©er des labels pour les localit√©s
    localite_labels <- sprintf(
      "<strong>üè† %s</strong><br/>üìã Type: %s<br>üìç H√¥pital le plus proche: %s<br>üìè Distance: %s km",
      localites_wgs84$Nom,
      localites_wgs84$`Type de localit√©`,
      localites_wgs84$`H√¥pital le plus proche`,
      localites_wgs84$`Distance (km)`
    ) %>% lapply(htmltools::HTML)
    
    # Cr√©er la carte
    leaflet() %>%
      addTiles() %>%
      # Centrer sur le Cameroun
      setView(lng = 12.354722, lat = 7.369722, zoom = 6) %>%
      # R√©gions administratives
      addPolygons(
        data = regions_wgs84,
        group = "R√©gions administratives",
        color = "#2c3e50",
        weight = 2,
        fillOpacity = 0.3,
        fillColor = ~palette_regions(`Population de la r√©gion`),
        label = region_labels,
        layerId = ~R√©gion,
        highlightOptions = highlightOptions(
          weight = 3,
          color = "#e74c3c",
          fillOpacity = 0.5,
          bringToFront = TRUE
        )
      ) %>%
      # H√¥pitaux
      addCircleMarkers(
        data = hopitaux_wgs84,
        group = "H√¥pitaux",
        color = "#c0392b",
        fillColor = "#e74c3c",
        fillOpacity = 0.9,
        radius = 8,
        stroke = TRUE,
        weight = 2,
        label = hopital_labels,
        layerId = ~hopital_id,
        popup = ~paste(
          "<div style='max-width: 300px;'>",
          "<h4 style='color: #c0392b;'>üè•", Nom_Hopital, "</h4>",
          "<hr style='margin: 5px 0;'>",
          "<strong>üìç R√©gion:</strong> ", ifelse(is.na(R√©gion), "Non sp√©cifi√©", R√©gion), "<br>",
          "<strong>üèõÔ∏è D√©partement:</strong> ", ifelse(is.na(D√©partement), "Non sp√©cifi√©", D√©partement), "<br>",
          "<strong>üè• H√¥pitaux dans la r√©gion:</strong> ", `Nombre d'h√¥pitaux dans la r√©gion`, "<br>",
          "<strong>üë• Population r√©gionale:</strong> ", format(round(`Population de la r√©gion`), big.mark = " "), " habitants",
          "</div>"
        )
      ) %>%
      # Localit√©s
      addCircleMarkers(
        data = localites_wgs84,
        group = "Localit√©s",
        color = ~palette_localites(`Type de localit√©`),
        fillColor = ~palette_localites(`Type de localit√©`),
        fillOpacity = 0.8,
        radius = 5,
        stroke = TRUE,
        weight = 1,
        label = localite_labels,
        layerId = ~place_id,
        popup = ~paste(
          "<div style='max-width: 300px;'>",
          "<h4 style='color: #2c3e50;'>üè†", Nom, "</h4>",
          "<hr style='margin: 5px 0;'>",
          "<strong>üìã Type:</strong> ", `Type de localit√©`, "<br>",
          "<strong>üìç H√¥pital le plus proche:</strong> ", `H√¥pital le plus proche`, "<br>",
          "<strong>üìè Distance:</strong> ", `Distance (km)`, " km",
          "</div>"
        )
      ) %>%
      # Contr√¥le des couches
      addLayersControl(
        overlayGroups = c("R√©gions administratives", "H√¥pitaux", "Localit√©s"),
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
      # L√©gende pour les localit√©s
      addLegend(
        position = "bottomright",
        pal = palette_localites,
        values = fclass_display,
        title = "Type de localit√©",
        opacity = 0.8
      ) %>%
      # L√©gende pour les r√©gions
      addLegend(
        position = "bottomleft",
        pal = palette_regions,
        values = population_values,
        title = "Population r√©gionale",
        opacity = 0.6,
        labFormat = labelFormat(big.mark = " ")
      )
  })
  
  # Mise √† jour des buffers
  observe({
    buffers <- buffer_a_afficher()
    rv_analysis$current_buffers <- buffers
    
    leafletProxy("interactive_map") %>%
      clearGroup("Zones de tampon")
    
    if (!is.null(buffers)) {
      leafletProxy("interactive_map") %>%
        addPolygons(
          data = buffers,
          group = "Zones de tampon",
          color = "#e74c3c",
          weight = 1,
          fillColor = "lightcoral",
          fillOpacity = 0.3,
          label = paste("Zone d'acc√®s", input$buffer_dist, "km")
        ) %>%
        addLayersControl(
          overlayGroups = c("R√©gions administratives", "H√¥pitaux", "Localit√©s", "Zones de tampon"),
          options = layersControlOptions(collapsed = FALSE)
        )
    }
  })
  
  # Filtrage des localit√©s
  observe({
    localites_filtrees <- localites_wgs84 %>%
      filter(`Type de localit√©` %in% input$fclass_select)
    
    palette_localites <- colorFactor(
      viridis_pal(option = "C")(length(fclass_display)),
      domain = fclass_display
    )
    
    localite_labels <- sprintf(
      "<strong>üè† %s</strong><br/>üìã Type: %s<br>üìç H√¥pital le plus proche: %s<br>üìè Distance: %s km",
      localites_filtrees$Nom,
      localites_filtrees$`Type de localit√©`,
      localites_filtrees$`H√¥pital le plus proche`,
      localites_filtrees$`Distance (km)`
    ) %>% lapply(htmltools::HTML)
    
    leafletProxy("interactive_map") %>%
      clearGroup("Localit√©s") %>%
      addCircleMarkers(
        data = localites_filtrees,
        group = "Localit√©s",
        color = ~palette_localites(`Type de localit√©`),
        fillColor = ~palette_localites(`Type de localit√©`),
        fillOpacity = 0.8,
        radius = 5,
        stroke = TRUE,
        weight = 1,
        label = localite_labels,
        layerId = ~place_id,
        popup = ~paste(
          "<div style='max-width: 300px;'>",
          "<h4 style='color: #2c3e50;'>üè†", Nom, "</h4>",
          "<hr style='margin: 5px 0;'>",
          "<strong>üìã Type:</strong> ", `Type de localit√©`, "<br>",
          "<strong>üìç H√¥pital le plus proche:</strong> ", `H√¥pital le plus proche`, "<br>",
          "<strong>üìè Distance:</strong> ", `Distance (km)`, " km",
          "</div>"
        )
      )
  })
  
  # Gestion des clics sur la carte (espaces vides)
  observeEvent(input$interactive_map_click, {
    click_data <- input$interactive_map_click
    
    # R√©initialiser les autres s√©lections
    rv_analysis$clicked_hospital_id <- NULL
    rv_analysis$clicked_place_id <- NULL
    rv_analysis$clicked_region <- NULL
    
    # V√©rifier si le clic est sur une r√©gion
    if (!is.null(click_data)) {
      click_point <- st_sf(
        geometry = st_sfc(st_point(c(click_data$lng, click_data$lat)), crs = 4326)
      )
      
      # Trouver la r√©gion correspondante
      regions_intersected <- st_intersects(click_point, regions_wgs84)
      
      if (length(regions_intersected[[1]]) > 0) {
        region_index <- regions_intersected[[1]][1]
        rv_analysis$clicked_region <- regions_wgs84$R√©gion[region_index]
      } else {
        rv_analysis$region_data <- "üåç Aucune information r√©gionale disponible pour cette zone.\nCliquez sur une r√©gion color√©e pour obtenir des informations."
      }
    }
  })
  
  # Gestion des clics sur les marqueurs
  observeEvent(input$interactive_map_marker_click, {
    click_data <- input$interactive_map_marker_click
    
    if (!is.null(click_data$id)) {
      # V√©rifier si c'est un h√¥pital
      if (click_data$id %in% hopitaux_wgs84$hopital_id) {
        rv_analysis$clicked_hospital_id <- click_data$id
        rv_analysis$clicked_place_id <- NULL
        rv_analysis$clicked_region <- NULL
      } 
      # V√©rifier si c'est une localit√©
      else if (click_data$id %in% localites_wgs84$place_id) {
        rv_analysis$clicked_place_id <- click_data$id
        rv_analysis$clicked_hospital_id <- NULL
        rv_analysis$clicked_region <- NULL
      }
    }
  })
  
  # Gestion des clics sur les polygones (r√©gions)
  observeEvent(input$interactive_map_shape_click, {
    click_data <- input$interactive_map_shape_click
    
    if (!is.null(click_data$id) && click_data$id %in% regions_wgs84$R√©gion) {
      rv_analysis$clicked_region <- click_data$id
      rv_analysis$clicked_hospital_id <- NULL
      rv_analysis$clicked_place_id <- NULL
    }
  })
  
  # Analyse du clic sur un h√¥pital
  observeEvent(rv_analysis$clicked_hospital_id, {
    hospital_id_clicked <- rv_analysis$clicked_hospital_id
    
    if (is.null(hospital_id_clicked) || hospital_id_clicked == "") return()
    
    clicked_hopital <- hopital_projete_enriched %>%
      filter(hopital_id == hospital_id_clicked)
    
    if (nrow(clicked_hopital) == 0) return()
    
    dist_m <- input$buffer_dist * 1000
    
    if (dist_m > 0) {
      buffer_clicked <- st_buffer(clicked_hopital, dist = dist_m)
      
      # Extraction de la population dans le buffer
      total_pop_in_buffer <- extract_population(buffer_clicked)
      
      # Comptage des localit√©s par type (dans le tampon uniquement)
      localities_in_buffer <- st_filter(place_projete_enriched, buffer_clicked, 
                                        .predicate = st_intersects)
      
      locality_counts <- localities_in_buffer %>%
        st_drop_geometry() %>%
        group_by(`Type de localit√©`) %>%
        tally(name = "Count") %>%
        arrange(desc(Count))
      
      locality_text <- if (nrow(locality_counts) > 0) {
        paste(sapply(1:nrow(locality_counts), function(i) {
          paste("  ‚Ä¢ ", locality_counts$`Type de localit√©`[i], ": ", locality_counts$Count[i])
        }), collapse = "\n")
      } else {
        "  Aucune localit√© trouv√©e dans le tampon."
      }
      
      # Calcul du nombre total de localit√©s
      total_localities <- sum(locality_counts$Count, na.rm = TRUE)
      
      rv_analysis$hospital_data <- sprintf(
        "üè• H√îPITAL S√âLECTIONN√â : %s\nüìè Distance de Tampon : %d km\n%s\nüë• POPULATION COUVERTE :\n%s habitants\n%s\nüèòÔ∏è LOCALIT√âS COUVERTES :\nTotal : %d localit√©(s)\n%s\nüìä D√©tail par type :\n%s\n%s\nüó∫Ô∏è INFORMATIONS R√âGIONALES :\nüìç R√©gion : %s\nüë• Population r√©gionale : %s habitants\nüè• H√¥pitaux dans la r√©gion : %s\n%s\nüí° Conseil : Ajustez la distance du tampon pour modifier la zone d'analyse.",
        clicked_hopital$Nom_Hopital,
        input$buffer_dist,
        strrep("=", 50),
        format(round(total_pop_in_buffer), big.mark = " ", scientific = FALSE),
        strrep("=", 50),
        total_localities,
        strrep("-", 30),
        locality_text,
        strrep("=", 50),
        ifelse(is.na(clicked_hopital$R√©gion), "Non sp√©cifi√©", clicked_hopital$R√©gion),
        format(round(clicked_hopital$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
        clicked_hopital$`Nombre d'h√¥pitaux dans la r√©gion`,
        strrep("=", 50)
      )
    } else {
      rv_analysis$hospital_data <- sprintf(
        "üè• H√îPITAL S√âLECTIONN√â : %s\nüìè Distance de Tampon : 0 km\n%s\n‚ùå Augmentez la distance du tampon pour effectuer l'analyse.\n%s\nüó∫Ô∏è INFORMATIONS R√âGIONALES :\nüìç R√©gion : %s\nüë• Population r√©gionale : %s habitants\nüè• H√¥pitaux dans la r√©gion : %s\n%s\nüí° Conseil : Augmentez la distance du tampon pour analyser la couverture.",
        clicked_hopital$Nom_Hopital,
        strrep("-", 50),
        strrep("=", 50),
        ifelse(is.na(clicked_hopital$R√©gion), "Non sp√©cifi√©", clicked_hopital$R√©gion),
        format(round(clicked_hopital$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
        clicked_hopital$`Nombre d'h√¥pitaux dans la r√©gion`,
        strrep("=", 50)
      )
    }
  })
  
  # Analyse du clic sur une localit√©
  observeEvent(rv_analysis$clicked_place_id, {
    place_id_clicked <- rv_analysis$clicked_place_id
    
    if (is.null(place_id_clicked) || place_id_clicked == "") return()
    
    clicked_place <- place_projete_enriched %>%
      filter(place_id == place_id_clicked)
    
    if (nrow(clicked_place) > 0) {
      rv_analysis$place_data <- sprintf(
        "üè† LOCALIT√â S√âLECTIONN√âE : %s\nüìã Type : %s\n%s\nüìç H√¥pital le plus proche : %s\nüìè Distance : %s km\n%s\nüí° Conseil : Cette distance repr√©sente le trajet √† vol d'oiseau jusqu'√† l'h√¥pital le plus proche.",
        clicked_place$Nom,
        clicked_place$`Type de localit√©`,
        strrep("-", 40),
        clicked_place$`H√¥pital le plus proche`,
        clicked_place$`Distance (km)`,
        strrep("=", 40)
      )
    }
  })
  
  # Analyse du clic sur une r√©gion
  observeEvent(rv_analysis$clicked_region, {
    region_name <- rv_analysis$clicked_region
    
    if (!is.null(region_name)) {
      region_info <- regions_interactives %>%
        filter(R√©gion == region_name) %>%
        st_drop_geometry()
      
      if (nrow(region_info) > 0) {
        rv_analysis$region_data <- sprintf(
          "üó∫Ô∏è R√âGION S√âLECTIONN√âE : %s\n%s\nüë• Population : %s habitants\nüè• Nombre d'h√¥pitaux : %s\n%s\nüí° Conseil : Cliquez sur un h√¥pital pour analyser sa couverture avec le tampon actuel de %d km.",
          region_info$R√©gion,
          strrep("=", 40),
          format(round(region_info$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
          region_info$`Nombre d'h√¥pitaux dans la r√©gion`,
          strrep("=", 40),
          input$buffer_dist
        )
      }
    }
  })
  
  # Sorties textuelles
  output$hospital_analysis <- renderPrint({
    cat(rv_analysis$hospital_data)
  })
  
  output$place_analysis <- renderPrint({
    cat(rv_analysis$place_data)
  })
  
  output$region_analysis <- renderPrint({
    cat(rv_analysis$region_data)
  })
}

# ====================================================================
# LANCEMENT DE L'APPLICATION
# ====================================================================

shinyApp(ui = ui, server = server)



















































































































































library(leaflet)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(viridis)
library(htmlwidgets)
library(leaflet.extras)

# ====================================================================
# CONFIGURATION ET CHARGEMENT DES DONN√âES
# ====================================================================

base_path <- getwd()
output_dir <- file.path(base_path, "export_carte_complete")

if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Dossier de sortie cr√©√© :", output_dir, "\n")
}

# Chargement des donn√©es
tryCatch({
  HPT_shp <- file.path(base_path, "data/data2/202303-osm2igeo-cameroun-shp-wgs84-4326/202303_OSM2IGEO_CAMEROUN_SHP_WGS84_4326/I_OSM_ZONE_ACTIVITE/PAI_SANTE.shp")
  hopital <- st_read(HPT_shp, quiet = TRUE)
  
  CMR_shp_3 <- file.path(base_path, "data/data2/shapefiles_limites_administratives_GADM_Cameroun/gadm41_CMR_3.shp")
  cameroun_limite_3 <- st_read(CMR_shp_3, quiet = TRUE)
  
  place_shp <- file.path(base_path, "data/data2/cameroon-251116-free.shp/gis_osm_places_free_1.shp")
  place <- st_read(place_shp, quiet = TRUE)
  fclass_display <- c("city", "town", "village", "hamlet", "suburb", "locality", "national_capital")
  place <- place %>% filter(fclass %in% fclass_display)
  
  raster_file_path <- file.path(base_path, "data/data2/worldpop/cmr_pop_2025_CN_100m_R2024B_v1.tif")
  worldpop <- rast(raster_file_path)
  
  cat("Donn√©es charg√©es avec succ√®s.\n")
}, error = function(e) {
  stop("Erreur chargement donn√©es : ", e$message)
})

# V√©rification des donn√©es WorldPop
cat("=== V√âRIFICATION WORLDPOP ===\n")
cat("Population totale raster:", global(worldpop, "sum", na.rm = TRUE)[[1]], "hab\n")
cat("=====================================\n")

# Projection
CRS_WGS84 <- "EPSG:4326"
regions_wgs84 <- st_transform(cameroun_limite_3, crs = CRS_WGS84)
hopital_wgs84 <- st_transform(hopital, crs = CRS_WGS84)
place_wgs84 <- st_transform(place, crs = CRS_WGS84)

# ====================================================================
# EXTRACTION R√âELLE - SOMME DES PIXELS PAR R√âGION
# ====================================================================

# 1. H√¥pitaux par r√©gion
hopitaux_par_region <- st_join(hopital_wgs84, regions_wgs84, join = st_intersects) %>%
  st_drop_geometry() %>% group_by(NAME_1) %>% tally(name = "Nb_Hopitaux") %>% ungroup()

# 2. SOMME DIRECTE DES PIXELS PAR R√âGION
cat("SOMME DIRECTE des pixels WorldPop par r√©gion...\n")

# Pr√©parer les r√©gions avec superficie
regions_avec_superficie <- regions_wgs84 %>% 
  group_by(NAME_1) %>% 
  summarise(geometry = st_union(geometry)) %>% 
  ungroup() %>% 
  st_make_valid() %>%
  mutate(
    Superficie_km2 = as.numeric(st_area(geometry)) / 1e6
  )

# Fonction pour SOMMER les pixels d'une r√©gion
sommer_pixels_region <- function(region_sf) {
  tryCatch({
    region_name <- region_sf$NAME_1
    
    # Convertir la r√©gion en vecteur terra
    region_vect <- vect(region_sf)
    
    # M√©thode robuste : crop + mask + somme globale
    raster_crop <- crop(worldpop, region_vect)
    raster_mask <- mask(raster_crop, region_vect)
    
    # SOMME DIRECTE des valeurs des pixels
    somme_pixels <- global(raster_mask, "sum", na.rm = TRUE)[[1]]
    
    if (is.na(somme_pixels)) {
      somme_pixels <- 0
    }
    
    cat("R√©gion:", region_name, "- Population:", round(somme_pixels), "hab\n")
    return(somme_pixels)
    
  }, error = function(e) {
    cat("Erreur pour", region_sf$NAME_1, ": 0 hab\n")
    return(0)
  })
}

# Appliquer la somme des pixels pour chaque r√©gion
populations_regions <- numeric(nrow(regions_avec_superficie))

for (i in 1:nrow(regions_avec_superficie)) {
  region <- regions_avec_superficie[i, ]
  populations_regions[i] <- sommer_pixels_region(region)
}

# CORRECTION : Garder toutes les colonnes n√©cessaires ensemble
population_par_region <- regions_avec_superficie %>%
  mutate(Population = populations_regions) %>%
  # NE PAS supprimer la g√©om√©trie et garder Superficie_km2
  select(NAME_1, Population, Superficie_km2, geometry)

# 3. CALCUL DES DENSIT√âS (SEULEMENT APR√àS LA SOMME) - CORRIG√â
regions_interactives <- population_par_region %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  mutate(
    Nb_Hopitaux = replace_na(Nb_Hopitaux, 0),
    Population = replace_na(Population, 0),
    # DENSIT√â CALCUL√âE √Ä PARTIR DES DONN√âES R√âELLES
    Densite_hab_km2 = round(Population / Superficie_km2, 2)
  ) %>% 
  rename(R√©gion = NAME_1)

# 4. STATISTIQUES NATIONALES - SOMME DES R√âGIONS
population_totale_nationale <- sum(population_par_region$Population, na.rm = TRUE)
superficie_totale_nationale <- sum(regions_avec_superficie$Superficie_km2, na.rm = TRUE)

cameroun_global <- data.frame(
  Superficie_totale_km2 = superficie_totale_nationale,
  Population_totale = population_totale_nationale
) %>%
  mutate(
    Densite_totale = round(Population_totale / Superficie_totale_km2, 2)
  )

# V√©rification coh√©rence
population_raster_totale <- global(worldpop, "sum", na.rm = TRUE)[[1]]

cat("\n=== V√âRIFICATION COH√âRENCE ===\n")
cat("Population totale (raster WorldPop):", round(population_raster_totale), "hab\n")
cat("Population totale (somme r√©gions):", round(population_totale_nationale), "hab\n")
cat("Diff√©rence:", round(population_raster_totale - population_totale_nationale), "hab\n")
cat("Ratio:", round(population_totale_nationale/population_raster_totale * 100, 1), "%\n")
cat("Superficie totale:", round(superficie_totale_nationale), "km¬≤\n")
cat("Densit√© moyenne:", cameroun_global$Densite_totale, "hab/km¬≤\n")

# Afficher le d√©tail par r√©gion
cat("\n=== D√âTAIL PAR R√âGION ===\n")
regions_interactives %>%
  st_drop_geometry() %>%
  select(R√©gion, Population, Superficie_km2, Densite_hab_km2) %>%
  arrange(desc(Population)) %>%
  print(n = Inf)
cat("======================================\n")

# 5. H√¥pitaux enrichis avec donn√©es r√©elles
hopital_enriched <- hopital_wgs84 %>%
  mutate(unique_id = paste0("h_", row_number())) %>%
  st_join(regions_wgs84 %>% select(NAME_1, NAME_2), join = st_intersects) %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  left_join(
    regions_interactives %>% st_drop_geometry() %>% select(R√©gion, Population, Superficie_km2, Densite_hab_km2), 
    by = c("NAME_1" = "R√©gion")
  ) %>%
  rename(Nom_Hopital = NOM, R√©gion = NAME_1, D√©partement = NAME_2) %>%
  mutate(
    Nb_Hopitaux = replace_na(Nb_Hopitaux, 0), 
    Population = replace_na(Population, 0),
    Superficie_km2 = replace_na(Superficie_km2, 0),
    Densite_hab_km2 = round(Population / Superficie_km2, 2)
  )

# 6. Localit√©s avec distances et PRIORIT√â (conserv√©e mais non affich√©e)
place_enriched <- place_wgs84 %>%
  mutate(place_id = paste0("p_", row_number())) %>%
  mutate(
    nearest_hopital_index = st_nearest_feature(., hopital_wgs84),
    nearest_hopital_name = hopital_wgs84$NOM[nearest_hopital_index],
    distance_to_nearest_hopital_m = st_distance(., hopital_wgs84[nearest_hopital_index, ], by_element = TRUE),
    Distance_km = round(as.numeric(distance_to_nearest_hopital_m) / 1000, 2),
    # PRIORIT√â conserv√©e pour l'ordre d'affichage mais non affich√©e
    Priorite = case_when(
      fclass == "national_capital" ~ 100,
      fclass == "city" ~ 90,
      fclass == "town" ~ 80,
      fclass == "suburb" ~ 70,
      fclass == "village" ~ 60,
      fclass == "locality" ~ 50,
      fclass == "hamlet" ~ 40,
      TRUE ~ 10
    ),
    # TERMINOLOGIE FRAN√áAISE AM√âLIOR√âE
    Type_entite = case_when(
      fclass == "national_capital" ~ "Capitale Nationale",
      fclass == "city" ~ "Ville Principale",
      fclass == "town" ~ "Ville Secondaire",
      fclass == "suburb" ~ "Quartier P√©riph√©rique",
      fclass == "village" ~ "Village",
      fclass == "locality" ~ "Localit√©",
      fclass == "hamlet" ~ "Hameau",
      TRUE ~ "Entit√© Territoriale"
    )
  ) %>% 
  rename(Nom = name) %>%
  arrange(desc(Priorite))  # Trie par priorit√© d√©croissante

# ====================================================================
# CR√âATION DE LA CARTE AVEC DONN√âES R√âELLES
# ====================================================================

creer_carte_avancee <- function() {
  cat("üîÑ Cr√©ation de la carte avec donn√©es r√©elles...\n")
  
  # PALETTE DE COULEURS - version pr√©c√©dente qui fonctionnait
  types_entites <- c("Capitale Nationale", "Ville Principale", "Ville Secondaire", 
                     "Quartier P√©riph√©rique", "Village", "Localit√©", "Hameau")
  
  # Couleurs d√©gressives du rouge au vert
  palette_entites <- colorFactor(
    palette = c(
      "Capitale Nationale" = "#B22222",    # Rouge brique
      "Ville Principale" = "#DC143C",      # Crimson
      "Ville Secondaire" = "#FF6347",      # Tomato
      "Quartier P√©riph√©rique" = "#FFA500", # Orange
      "Village" = "#FFD700",               # Gold
      "Localit√©" = "#9ACD32",              # YellowGreen
      "Hameau" = "#32CD32"                 # LimeGreen
    ),
    domain = types_entites
  )
  
  palette_regions <- colorNumeric("YlOrRd", domain = regions_interactives$Densite_hab_km2, na.color = "transparent")
  
  # Labels avec donn√©es r√©elles
  hopital_labels <- sprintf(
    "<strong>üè• %s</strong><br>üìç R√©gion: %s<br>üèõÔ∏è D√©partement: %s<br>üë• Population: %s<br>üìê Superficie: %s km¬≤<br>üìä Densit√©: %s hab/km¬≤<br>üè• H√¥pitaux r√©gion: %s",
    hopital_enriched$Nom_Hopital,
    ifelse(is.na(hopital_enriched$R√©gion), "Non sp√©cifi√©", hopital_enriched$R√©gion),
    ifelse(is.na(hopital_enriched$D√©partement), "Non sp√©cifi√©", hopital_enriched$D√©partement),
    format(round(hopital_enriched$Population), big.mark = " "),
    format(round(hopital_enriched$Superficie_km2), big.mark = " "),
    format(round(hopital_enriched$Densite_hab_km2), big.mark = " "),
    hopital_enriched$Nb_Hopitaux
  ) %>% lapply(htmltools::HTML)
  
  entite_labels <- sprintf(
    "<strong>%s %s</strong><br>üìã Type: %s<br>üìç H√¥pital proche: %s<br>üìè Distance: %s km",
    case_when(
      place_enriched$Type_entite == "Capitale Nationale" ~ "üèõÔ∏è",
      place_enriched$Type_entite == "Ville Principale" ~ "üèôÔ∏è",
      place_enriched$Type_entite == "Ville Secondaire" ~ "üèòÔ∏è",
      place_enriched$Type_entite == "Quartier P√©riph√©rique" ~ "üè¢",
      place_enriched$Type_entite == "Village" ~ "üè°",
      place_enriched$Type_entite == "Localit√©" ~ "üìç",
      place_enriched$Type_entite == "Hameau" ~ "üè†",
      TRUE ~ "üè†"
    ),
    place_enriched$Nom,
    place_enriched$Type_entite,
    place_enriched$nearest_hopital_name,
    place_enriched$Distance_km
  ) %>% lapply(htmltools::HTML)
  
  # Panneau de contr√¥le avec donn√©es r√©elles
  total_hospitals <- nrow(hopital_enriched)
  total_entites <- nrow(place_enriched)
  total_regions <- nrow(regions_interactives)
  
  control_html <- HTML(paste0(
    '<div id="custom-control" style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); max-width: 320px;">
      <h4 style="margin: 0 0 15px 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px;">
        üè• Carte de Couverture Sanitaire
      </h4>
      
      <div style="margin-bottom: 15px;">
        <h5 style="margin: 0 0 8px 0; color: #34495e; font-size: 14px;">üá®üá≤ Cameroun - Donn√©es R√©elles :</h5>
        <div style="font-size: 11px; line-height: 1.4; background: #e8f7f0; padding: 8px; border-radius: 4px; border-left: 4px solid #27ae60;">
          <div>üó∫Ô∏è <strong>Superficie:</strong> ', format(round(cameroun_global$Superficie_totale_km2), big.mark = " "), ' km¬≤</div>
          <div>üë• <strong>Population:</strong> ', format(round(cameroun_global$Population_totale), big.mark = " "), ' hab</div>
          <div>üìä <strong>Densit√©:</strong> ', cameroun_global$Densite_totale, ' hab/km¬≤</div>
          <div style="font-size: 9px; color: #27ae60; margin-top: 3px;">
            üìç Donn√©es WorldPop 2025 - Somme directe des pixels
          </div>
        </div>
      </div>
      
      <div style="margin-bottom: 15px;">
        <h5 style="margin: 0 0 8px 0; color: #34495e; font-size: 14px;">üìä Infrastructures :</h5>
        <div style="font-size: 11px; line-height: 1.4;">
          <div>üè• <strong>H√¥pitaux:</strong> ', total_hospitals, '</div>
          <div>üèòÔ∏è <strong>Entit√©s Territoriales:</strong> ', total_entites, '</div>
          <div>üó∫Ô∏è <strong>R√©gions:</strong> ', total_regions, '</div>
        </div>
      </div>
    </div>'
  ))
  
  # Cr√©ation de la carte - VERSION PR√âC√âDENTE QUI FONCTIONNAIT
  carte <- leaflet() %>%
    addTiles() %>%
    setView(lng = 12.354722, lat = 7.369722, zoom = 6) %>%
    
    # Couche des r√©gions avec densit√©s R√âELLES
    addPolygons(
      data = regions_interactives,
      group = "R√©gions administratives",
      color = "#2c3e50", weight = 2, fillOpacity = 0.4,
      fillColor = ~palette_regions(Densite_hab_km2),
      label = ~sprintf(
        "<strong>üó∫Ô∏è %s</strong><br>üë• Population: %s<br>üè• H√¥pitaux: %s<br>üìê Superficie: %s km¬≤<br>üìä Densit√©: %s hab/km¬≤", 
        R√©gion, 
        format(round(Population), big.mark = " "), 
        Nb_Hopitaux,
        format(round(Superficie_km2), big.mark = " "),
        format(round(Densite_hab_km2), big.mark = " ")
      ) %>% lapply(htmltools::HTML),
      highlightOptions = highlightOptions(weight = 3, color = "#e74c3c", fillOpacity = 0.6)
    ) %>%
    
    # Couche des ENTIT√âS TERRITORIALES
    addCircleMarkers(
      data = place_enriched,
      group = "Entit√©s Territoriales",
      color = ~palette_entites(Type_entite),
      fillColor = ~palette_entites(Type_entite), 
      fillOpacity = 0.9,
      radius = ~case_when(
        Priorite >= 90 ~ 10,
        Priorite >= 80 ~ 8,
        Priorite >= 70 ~ 6,
        Priorite >= 60 ~ 5,
        TRUE ~ 4
      ),
      stroke = TRUE, 
      weight = ~case_when(
        Priorite >= 90 ~ 3,
        Priorite >= 80 ~ 2,
        TRUE ~ 1
      ),
      label = entite_labels,
      options = pathOptions(interactive = TRUE),
      clusterOptions = markerClusterOptions(
        zoomToBoundsOnClick = TRUE,
        spiderfyOnMaxZoom = TRUE,
        showCoverageOnHover = TRUE
      )
    ) %>%
    
    # Couche des h√¥pitaux
    addCircleMarkers(
      data = hopital_enriched,
      group = "H√¥pitaux",
      color = "#c0392b", 
      fillColor = "#e74c3c", 
      fillOpacity = 0.95,
      radius = 8, 
      stroke = TRUE, 
      weight = 3,
      label = hopital_labels,
      options = pathOptions(interactive = TRUE)
    ) %>%
    
    # Fonctionnalit√©s
    addMeasure(
      position = "topleft",
      primaryLengthUnit = "kilometers",
      primaryAreaUnit = "sqmeters",
      activeColor = "#3D535D",
      completedColor = "#7D4479"
    ) %>%
    
    addLayersControl(
      overlayGroups = c("H√¥pitaux", "Entit√©s Territoriales", "R√©gions administratives"),
      options = layersControlOptions(collapsed = FALSE)
    ) %>%
    
    addResetMapButton() %>%
    
    # L√âGENDE - version pr√©c√©dente
    addLegend(
      position = "bottomright",
      pal = palette_entites, 
      values = types_entites,
      title = "Type d'entit√© territoriale", 
      opacity = 0.9
    ) %>%
    
    addLegend(
      position = "bottomleft",
      pal = palette_regions, 
      values = regions_interactives$Densite_hab_km2,
      title = "Densit√© (hab/km¬≤)", 
      opacity = 0.7,
      labFormat = labelFormat(big.mark = " ")
    ) %>%
    
    addControl(
      html = control_html,
      position = "topright"
    ) %>%
    
    # RECHERCHE
    addSearchFeatures(
      targetGroups = c("H√¥pitaux", "Entit√©s Territoriales"),
      options = searchFeaturesOptions(
        zoom = 18,
        openPopup = TRUE,
        firstTipSubmit = TRUE,
        autoCollapse = FALSE,
        hideMarkerOnCollapse = TRUE,
        position = "topleft"
      )
    )
  
  cat("‚úÖ Carte cr√©√©e avec succ√®s!\n")
  return(carte)
}

# ====================================================================
# EXPORT
# ====================================================================

exporter_carte_complete <- function() {
  cat("üöÄ Export de la carte avec donn√©es r√©elles...\n")
  
  carte_complete <- creer_carte_avancee()
  html_file <- file.path(output_dir, "carte_couverture_reelle_cameroun.html")
  
  saveWidget(
    carte_complete,
    file = html_file,
    selfcontained = TRUE,
    title = "Carte Interactive - Donn√©es WorldPop R√©elles - Cameroun"
  )
  
  if (file.exists(html_file)) {
    cat("üéâ SUCC√àS ! Carte export√©e :", html_file, "\n")
    browseURL(html_file)
    return(html_file)
  } else {
    cat("‚ùå ERREUR : Export √©chou√©\n")
    return(NULL)
  }
}

# LANCEMENT
exporter_carte_complete()