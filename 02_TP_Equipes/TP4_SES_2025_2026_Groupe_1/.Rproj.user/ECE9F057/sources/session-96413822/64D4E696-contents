library(shiny)
library(leaflet)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(viridis)
library(htmltools)

# ====================================================================
# CONFIGURATION ET CHARGEMENT DES DONN√âES STATIQUES
# ====================================================================


# --- D√©finition des Chemins ---
base_path <- "C:/Users/DELL/Desktop/TP3_SES_2025_2026_ASTOU_MAREME_LANDRY_YAMAHA"
output_dir <- file.path(base_path, "outputs")
scripts_dir <- file.path(base_path, "scripts")
data_dir <- file.path(base_path, "data")


if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Dossier de sortie cr√©√© :", output_dir, "\n")
}


# --- Importation des donn√©es ---
tryCatch({
  # H√¥pitaux
  HPT_shp <- file.path(base_path, "data/data2/202303-osm2igeo-cameroun-shp-wgs84-4326/202303_OSM2IGEO_CAMEROUN_SHP_WGS84_4326/I_OSM_ZONE_ACTIVITE/PAI_SANTE.shp")
  hopital <- st_read(HPT_shp, quiet = TRUE)
  
  # Limites administratives
  CMR_shp_3 <- file.path(base_path, "data/data2/shapefiles_limites_administratives_GADM_Cameroun/gadm41_CMR_3.shp")
  cameroun_limite_3 <- st_read(CMR_shp_3, quiet = TRUE)
  
  # Localit√©s
  place_shp <- file.path(base_path, "data/data2/cameroon-251116-free.shp/gis_osm_places_free_1.shp")
  place <- st_read(place_shp, quiet = TRUE)
  # AJOUT DE "national_capital" DANS LES TYPES DE LOCALIT√âS
  fclass_display <- c("city", "town", "village", "hamlet", "suburb", "locality", "national_capital")
  place <- place %>% filter(fclass %in% fclass_display)
  
  # Population
  raster_file_path <- file.path(base_path, "data/data2/worldpop/cmr_pop_2025_CN_100m_R2024B_v1.tif")
  worldpop <- rast(raster_file_path)
  
  cat("Toutes les donn√©es ont √©t√© charg√©es avec succ√®s.\n")
  
}, error = function(e) {
  stop("Erreur lors du chargement des donn√©es : ", e$message)
})

cat("=== INFORMATION RASTER WORLDPOP ===\n")
cat("Dimensions du raster:", dim(worldpop), "\n")
cat("R√©solution:", res(worldpop), "\n")
cat("Projection:", crs(worldpop), "\n")
cat("Nombre de cellules avec donn√©es:", global(!is.na(worldpop), "sum", na.rm = TRUE)[[1]], "\n")
cat("Valeurs uniques:", unique(values(worldpop))[1:10], "\n")
cat("===================================\n")

# --- Projection coh√©rente pour toutes les donn√©es ---
# Utiliser WGS84 (EPSG:4326) pour tout le projet
CRS_WGS84 <- "EPSG:4326"

# Convertir toutes les donn√©es en WGS84
regions_wgs84 <- st_transform(cameroun_limite_3, crs = CRS_WGS84)
hopital_wgs84 <- st_transform(hopital, crs = CRS_WGS84)
place_wgs84 <- st_transform(place, crs = CRS_WGS84)

# Le raster WorldPop est d√©j√† en WGS84, pas besoin de le reprojeter
worldpop_wgs84 <- worldpop

# --- Enrichissement des donn√©es ---

# 1. Nombre d'h√¥pitaux par r√©gion
hopitaux_par_region <- st_join(
  hopital_wgs84,
  regions_wgs84,
  join = st_intersects,
  left = FALSE
) %>%
  st_drop_geometry() %>%
  group_by(NAME_1) %>%
  tally(name = "Nb_Hopitaux") %>%
  ungroup()

# 2. Population par r√©gion - M√âTHODE CORRIG√âE
cat("Calcul de la population par r√©gion...\n")
population_par_region <- tryCatch({
  
  # Pr√©parer les r√©gions unifi√©es
  regions_union <- regions_wgs84 %>%
    group_by(NAME_1) %>%
    summarise(geometry = st_union(geometry)) %>%
    ungroup() %>%
    st_make_valid()
  
  # V√©rifier que le raster et les r√©gions ont la m√™me projection
  cat("Projection raster:", crs(worldpop_wgs84), "\n")
  cat("Projection r√©gions:", st_crs(regions_union)$wkt, "\n")
  
  # M√©thode robuste pour extraire la population
  pop_values <- numeric(nrow(regions_union))
  
  for (i in 1:nrow(regions_union)) {
    region <- regions_union[i, ]
    region_name <- region$NAME_1
    
    cat("Traitement de la r√©gion:", region_name, "\n")
    
    tryCatch({
      # Masquer le raster avec la r√©gion
      region_vect <- vect(region)
      raster_masque <- mask(worldpop_wgs84, region_vect)
      
      # Calculer la somme des valeurs de population
      pop_sum <- global(raster_masque, "sum", na.rm = TRUE)[[1]]
      
      if (!is.na(pop_sum) && pop_sum > 0) {
        pop_values[i] <- pop_sum
        cat("  ‚úì Population:", round(pop_sum), "habitants\n")
      } else {
        # Essayer avec la m√©thode extract si mask √©choue
        extracted <- extract(worldpop_wgs84, region_vect, fun = sum, na.rm = TRUE)
        if (!is.null(extracted) && ncol(extracted) >= 2 && !is.na(extracted[[2]][1])) {
          pop_values[i] <- extracted[[2]][1]
          cat("  ‚úì Population (m√©thode extract):", round(extracted[[2]][1]), "habitants\n")
        } else {
          pop_values[i] <- 0
          cat("  ‚úó Aucune donn√©e de population trouv√©e\n")
        }
      }
    }, error = function(e) {
      cat("  ‚úó Erreur pour", region_name, ":", e$message, "\n")
      pop_values[i] <- 0
    })
  }
  
  data.frame(
    NAME_1 = regions_union$NAME_1,
    Population = pop_values
  )
  
}, error = function(e) {
  cat("Erreur g√©n√©rale calcul population:", e$message, "\n")
  # Valeurs r√©alistes par d√©faut bas√©es sur la superficie
  regions_wgs84 %>%
    st_drop_geometry() %>%
    group_by(NAME_1) %>%
    summarise(Population = 500000) %>%  # Valeur r√©aliste par d√©faut
    ungroup()
})

# 3. R√©gions avec statistiques compl√®tes
regions_interactives <- regions_wgs84 %>%
  group_by(NAME_1) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup() %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  left_join(population_par_region, by = "NAME_1") %>%
  mutate(
    Nb_Hopitaux = replace_na(Nb_Hopitaux, 0),
    Population = replace_na(Population, 0)
  ) %>%
  rename(
    R√©gion = NAME_1,
    `Nombre d'h√¥pitaux dans la r√©gion` = Nb_Hopitaux,
    `Population de la r√©gion` = Population
  ) %>%
  select(R√©gion, `Nombre d'h√¥pitaux dans la r√©gion`, `Population de la r√©gion`)

# 4. H√¥pitaux enrichis - CORRECTION POUR L'AFFICHAGE
hopital_enriched <- hopital_wgs84 %>%
  mutate(
    hopital_id = as.character(seq_len(nrow(.))),
    # Cr√©er un identifiant unique bas√© sur les coordonn√©es pour √©viter les doublons
    unique_id = paste0("h_", row_number())
  ) %>%
  st_join(
    regions_wgs84 %>% select(NAME_1, NAME_2, NAME_3),
    join = st_intersects,
    left = TRUE
  ) %>%
  left_join(hopitaux_par_region, by = "NAME_1") %>%
  left_join(population_par_region, by = "NAME_1") %>%
  rename(
    Nom_Hopital = NOM,
    R√©gion = NAME_1,
    D√©partement = NAME_2,
    Arrondissement = NAME_3,
    `Nombre d'h√¥pitaux dans la r√©gion` = Nb_Hopitaux,
    `Population de la r√©gion` = Population
  ) %>%
  mutate(
    `Nombre d'h√¥pitaux dans la r√©gion` = replace_na(`Nombre d'h√¥pitaux dans la r√©gion`, 0),
    `Population de la r√©gion` = replace_na(`Population de la r√©gion`, 0)
  ) %>%
  select(hopital_id, unique_id, Nom_Hopital, Arrondissement, 
         D√©partement, R√©gion, `Nombre d'h√¥pitaux dans la r√©gion`, `Population de la r√©gion`)

# 5. Localit√©s avec distance au plus proche h√¥pital
place_enriched <- place_wgs84 %>%
  mutate(place_id = as.character(seq_len(nrow(.)))) %>%
  mutate(
    nearest_hopital_index = st_nearest_feature(., hopital_wgs84),
    nearest_hopital_name = hopital_wgs84$NOM[nearest_hopital_index],
    distance_to_nearest_hopital_m = st_distance(
      ., 
      hopital_wgs84[nearest_hopital_index, ], 
      by_element = TRUE
    ),
    `Distance (km)` = round(as.numeric(distance_to_nearest_hopital_m) / 1000, 2)
  ) %>%
  rename(
    `Type de localit√©` = fclass,
    Nom = name,
    `H√¥pital le plus proche` = nearest_hopital_name
  ) %>%
  select(place_id, Nom, `Type de localit√©`, `H√¥pital le plus proche`, `Distance (km)`)

# Debug: V√©rifier les types de localit√©s disponibles
cat("=== TYPES DE LOCALIT√âS DISPONIBLES ===\n")
table_places <- table(place_enriched$`Type de localit√©`)
print(table_places)
cat("=====================================\n")

# Debug: V√©rifier les donn√©es finales
cat("=== DEBUG INFORMATION FINALE ===\n")
cat("Nombre d'h√¥pitaux:", nrow(hopital_enriched), "\n")
cat("Nombre de localit√©s:", nrow(place_enriched), "\n")
cat("Nombre de r√©gions:", nrow(regions_interactives), "\n")
cat("Population totale estim√©e:", sum(population_par_region$Population, na.rm = TRUE), "\n")
cat("Extrait des populations r√©gionales:\n")
print(head(population_par_region))
cat("Extrait des h√¥pitaux:\n")
print(head(hopital_enriched %>% st_drop_geometry() %>% select(Nom_Hopital, R√©gion, hopital_id, unique_id)))
cat("Coordonn√©es du premier h√¥pital:", st_coordinates(hopital_enriched[1,]), "\n")
cat("=======================\n")

# ====================================================================
# INTERFACE UTILISATEUR
# ====================================================================

ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .sidebar-panel { 
        background-color: #f8f9fa; 
        padding: 15px;
        border-radius: 5px;
        height: 800px;
        overflow-y: auto;
      }
      .main-panel { 
        padding-left: 20px;
      }
      .analysis-output {
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        white-space: pre-wrap;
        max-height: 200px;
        overflow-y: auto;
      }
    "))
  ),
  
  titlePanel("Carte Interactive de Couverture Sanitaire du Cameroun"),
  
  sidebarLayout(
    sidebarPanel(
      width = 3,
      class = "sidebar-panel",
      
      h4("Param√®tres d'Analyse"),
      sliderInput("buffer_dist", 
                  "Distance de tampon (km) :",
                  min = 0, max = 100, value = 10, step = 1),
      hr(),
      
      h4("Filtrage des Localit√©s"),
      checkboxGroupInput("fclass_select",
                         "Afficher les localit√©s de type :",
                         choices = fclass_display,
                         selected = c("national_capital", "city", "town", "village")),  # CAPITALE S√âLECTIONN√âE PAR D√âFAUT
      hr(),
      
      h4("üìä Analyse d'Accessibilit√©"),
      tags$p("Cliquez sur un h√¥pital (point rouge) pour analyser le tampon", 
             style = "font-style: italic; color: #666; font-size: 12px;"),
      div(class = "analysis-output",
          verbatimTextOutput("hospital_analysis")
      ),
      
      h4("Proximit√© Sanitaire"),
      tags$p("Cliquez sur une localit√© (point color√©) pour trouver l'h√¥pital le plus proche", 
             style = "font-style: italic; color: #666; font-size: 12px;"),
      div(class = "analysis-output",
          verbatimTextOutput("place_analysis")
      ),
      
      h4("Information R√©gionale"),
      tags$p("Cliquez sur une r√©gion ou un espace vide de la carte", 
             style = "font-style: italic; color: #666; font-size: 12px;"),
      div(class = "analysis-output",
          verbatimTextOutput("region_analysis")
      ),
      
      tags$hr(),
      tags$p("Sources : OpenStreetMap, GADM, WorldPop (2025)", 
             style = "font-size: 10px; color: grey; margin-top: 20px; text-align: center;")
    ),
    
    mainPanel(
      width = 9,
      class = "main-panel",
      leafletOutput("interactive_map", height = "800px")
    )
  )
)

# ====================================================================
# LOGIQUE SERVEUR
# ====================================================================

server <- function(input, output, session) {
  
  # Valeurs r√©actives
  rv_analysis <- reactiveValues(
    hospital_data = "Cliquez sur un h√¥pital (point rouge) pour analyser le tampon.",
    place_data = "Cliquez sur une localit√© (point color√©) pour trouver l'h√¥pital le plus proche.",
    region_data = "Cliquez sur une r√©gion ou un espace vide de la carte pour obtenir les informations r√©gionales.",
    clicked_hospital_id = NULL,
    clicked_place_id = NULL,
    clicked_region = NULL,
    current_buffers = NULL
  )
  
  # Fonction pour extraire la population d'une zone - CORRIG√âE
  extract_population <- function(zone_sf) {
    tryCatch({
      cat("Extraction de la population pour une zone...\n")
      
      # Convertir en vecteur terra
      zone_vect <- vect(zone_sf)
      
      # Masquer le raster avec la zone
      raster_masque <- mask(worldpop_wgs84, zone_vect)
      
      # Calculer la somme
      pop_sum <- global(raster_masque, "sum", na.rm = TRUE)[[1]]
      
      if (!is.na(pop_sum) && pop_sum > 0) {
        cat("Population extraite:", round(pop_sum), "habitants\n")
        return(pop_sum)
      } else {
        # M√©thode alternative
        extracted <- extract(worldpop_wgs84, zone_vect, fun = sum, na.rm = TRUE)
        if (!is.null(extracted) && ncol(extracted) >= 2 && !is.na(extracted[[2]][1])) {
          alt_pop <- extracted[[2]][1]
          cat("Population extraite (m√©thode alternative):", round(alt_pop), "habitants\n")
          return(alt_pop)
        } else {
          cat("Aucune donn√©e de population trouv√©e\n")
          return(0)
        }
      }
    }, error = function(e) {
      cat("Erreur extraction population:", e$message, "\n")
      return(0)
    })
  }
  
  # Calcul r√©actif du tampon
  buffer_a_afficher <- reactive({
    req(input$buffer_dist)
    dist_m <- input$buffer_dist * 1000
    
    if (dist_m > 0) {
      buffers <- st_buffer(hopital_wgs84, dist = dist_m)
      return(buffers)
    } else {
      return(NULL)
    }
  })
  
  # Carte Leaflet principale - ORDRE DES COUCHES CORRIG√â
  output$interactive_map <- renderLeaflet({
    # Palette pour les types de localit√©s - AJUST√âE POUR INCLURE national_capital
    palette_localites <- colorFactor(
      viridis_pal(option = "C")(length(fclass_display)),
      domain = fclass_display
    )
    
    # Palette pour les r√©gions
    population_values <- regions_interactives$`Population de la r√©gion`
    palette_regions <- colorNumeric("Blues", domain = population_values, na.color = "transparent")
    
    # Debug final
    cat("=== DERNIER DEBUG AVANT AFFICHAGE ===\n")
    cat("H√¥pitaux √† afficher:", nrow(hopital_enriched), "\n")
    cat("Localit√©s √† afficher:", nrow(place_enriched), "\n")
    cat("Types de localit√©s pr√©sents:", unique(place_enriched$`Type de localit√©`), "\n")
    cat("====================================\n")
    
    # Cr√©er des labels pour les h√¥pitaux
    hopital_labels <- sprintf(
      "<strong> %s</strong><br/> R√©gion : %s<br/>Ô∏è D√©partement: %s<br/> Population r√©gionale : %s",
      hopital_enriched$Nom_Hopital,
      ifelse(is.na(hopital_enriched$R√©gion), "Non sp√©cifi√©", hopital_enriched$R√©gion),
      ifelse(is.na(hopital_enriched$D√©partement), "Non sp√©cifi√©", hopital_enriched$D√©partement),
      format(round(hopital_enriched$`Population de la r√©gion`), big.mark = " ", scientific = FALSE)
    ) %>% lapply(htmltools::HTML)
    
    # Cr√©er des labels pour les r√©gions
    region_labels <- sprintf(
      "<strong> %s</strong><br/> Population : %s habitants<br/> H√¥pitaux : %s",
      regions_interactives$R√©gion,
      format(round(regions_interactives$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
      regions_interactives$`Nombre d'h√¥pitaux dans la r√©gion`
    ) %>% lapply(htmltools::HTML)
    
    # Cr√©er des labels pour les localit√©s - AM√âLIOR√â POUR national_capital
    localite_labels <- sprintf(
      "<strong>%s %s</strong><br/> Type : %s<br> H√¥pital le plus proche : %s<br> Distance : %s km",
      case_when(
        place_enriched$`Type de localit√©` == "national_capital" ~ "üèõÔ∏è",
        place_enriched$`Type de localit√©` == "city" ~ "üèôÔ∏è",
        place_enriched$`Type de localit√©` == "town" ~ "üèòÔ∏è",
        place_enriched$`Type de localit√©` == "village" ~ "üè°",
        TRUE ~ "üè†"
      ),
      place_enriched$Nom,
      case_when(
        place_enriched$`Type de localit√©` == "national_capital" ~ "Capitale Nationale",
        place_enriched$`Type de localit√©` == "city" ~ "Ville",
        place_enriched$`Type de localit√©` == "town" ~ "Bourg",
        place_enriched$`Type de localit√©` == "village" ~ "Village",
        place_enriched$`Type de localit√©` == "hamlet" ~ "Hameau",
        place_enriched$`Type de localit√©` == "suburb" ~ "Banlieue",
        place_enriched$`Type de localit√©` == "locality" ~ "Localit√©",
        TRUE ~ place_enriched$`Type de localit√©`
      ),
      place_enriched$`H√¥pital le plus proche`,
      place_enriched$`Distance (km)`
    ) %>% lapply(htmltools::HTML)
    
    # Cr√©er la carte avec ORDRE DES COUCHES CORRIG√â
    leaflet() %>%
      addTiles() %>%
      # Centrer sur le Cameroun
      setView(lng = 12.354722, lat = 7.369722, zoom = 6) %>%
      
      # 1. COUCHE FONDAMENTALE : D√©coupage administratif (tout en bas)
      addPolygons(
        data = regions_interactives,
        group = "R√©gions administratives",
        color = "#2c3e50",
        weight = 2,
        fillOpacity = 0.2,  # L√©g√®rement plus transparent
        fillColor = ~palette_regions(`Population de la r√©gion`),
        label = region_labels,
        layerId = ~R√©gion,
        highlightOptions = highlightOptions(
          weight = 3,
          color = "#e74c3c",
          fillOpacity = 0.3,  # Plus transparent au survol
          bringToFront = FALSE  # Ne pas amener au premier plan
        )
      ) %>%
      
      # 2. COUCHE INTERM√âDIAIRE : Tampons (au-dessus des r√©gions)
      # Les tampons seront ajout√©s dynamiquement dans l'observe suivant
      
      # 3. COUCHE SUP√âRIEURE : Localit√©s (au-dessus des tampons)
      addCircleMarkers(
        data = place_enriched,
        group = "Localit√©s",
        color = ~palette_localites(`Type de localit√©`),
        fillColor = ~palette_localites(`Type de localit√©`),
        fillOpacity = 0.9,  # Plus opaque pour mieux voir
        radius = ~case_when(
          `Type de localit√©` == "national_capital" ~ 8,  # Taille augment√©e pour la capitale
          `Type de localit√©` == "city" ~ 6,
          TRUE ~ 5
        ),
        stroke = TRUE,
        weight = ~case_when(
          `Type de localit√©` == "national_capital" ~ 3,  # Contour √©pais pour la capitale
          TRUE ~ 1
        ),
        label = localite_labels,
        layerId = ~place_id,
        popup = ~paste(
          "<div style='max-width: 300px;'>",
          "<h4 style='color: #2c3e50;'>",
          case_when(
            `Type de localit√©` == "national_capital" ~ "üèõÔ∏è",
            `Type de localit√©` == "city" ~ "üèôÔ∏è",
            `Type de localit√©` == "town" ~ "üèòÔ∏è",
            `Type de localit√©` == "village" ~ "üè°",
            TRUE ~ "üè†"
          ),
          Nom, "</h4>",
          "<hr style='margin: 5px 0;'>",
          "<strong>üìã Type:</strong> ", 
          case_when(
            `Type de localit√©` == "national_capital" ~ "Capitale Nationale",
            `Type de localit√©` == "city" ~ "Ville",
            `Type de localit√©` == "town" ~ "Bourg",
            `Type de localit√©` == "village" ~ "Village",
            `Type de localit√©` == "hamlet" ~ "Hameau",
            `Type de localit√©` == "suburb" ~ "Banlieue",
            `Type de localit√©` == "locality" ~ "Localit√©",
            TRUE ~ `Type de localit√©`
          ), "<br>",
          "<strong> H√¥pital le plus proche :</strong> ", `H√¥pital le plus proche`, "<br>",
          "<strong> Distance :</strong> ", `Distance (km)`, " km",
          "</div>"
        )
      ) %>%
      
      # 4. COUCHE SUPREME : H√¥pitaux (tout en haut)
      addCircleMarkers(
        data = hopital_enriched,
        group = "H√¥pitaux",
        color = "#c0392b",
        fillColor = "#e74c3c",
        fillOpacity = 0.95,  # Tr√®s opaque pour une excellente visibilit√©
        radius = 12,  # Taille encore augment√©e
        stroke = TRUE,
        weight = 4,   # Contour tr√®s √©pais
        label = hopital_labels,
        layerId = ~unique_id,  # Utiliser l'ID unique
        popup = ~paste(
          "<div style='max-width: 300px;'>",
          "<h4 style='color: #c0392b;'>", Nom_Hopital, "</h4>",
          "<hr style='margin: 5px 0;'>",
          "<strong> R√©gion:</strong> ", ifelse(is.na(R√©gion), "Non sp√©cifi√©", R√©gion), "<br>",
          "<strong>Ô∏è D√©partement:</strong> ", ifelse(is.na(D√©partement), "Non sp√©cifi√©", D√©partement), "<br>",
          "<strong> H√¥pitaux dans la r√©gion:</strong> ", `Nombre d'h√¥pitaux dans la r√©gion`, "<br>",
          "<strong> Population r√©gionale:</strong> ", format(round(`Population de la r√©gion`), big.mark = " "), " habitants",
          "</div>"
        )
      ) %>%
      
      # Contr√¥le des couches - ORDRE CORRIG√â POUR LA L√âGENDE
      addLayersControl(
        overlayGroups = c("H√¥pitaux", "Localit√©s", "Zones de tampon", "R√©gions administratives"),  # Ordre invers√© dans la l√©gende
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
      
      # L√©gende pour les localit√©s
      addLegend(
        position = "bottomright",
        pal = palette_localites,
        values = fclass_display,
        title = "Type de localit√©",
        opacity = 0.9
      ) %>%
      
      # L√©gende pour les r√©gions
      addLegend(
        position = "bottomleft",
        pal = palette_regions,
        values = population_values,
        title = "Population r√©gionale",
        opacity = 0.7,
        labFormat = labelFormat(big.mark = " ")
      )
  })
  
  # Mise √† jour des buffers - CORRIG√â POUR L'ORDRE DES COUCHES
  observe({
    buffers <- buffer_a_afficher()
    rv_analysis$current_buffers <- buffers
    
    leafletProxy("interactive_map") %>%
      clearGroup("Zones de tampon")
    
    if (!is.null(buffers)) {
      leafletProxy("interactive_map") %>%
        # Ajouter les tampons APR√àS les r√©gions mais AVANT les localit√©s
        addPolygons(
          data = buffers,
          group = "Zones de tampon",
          color = "#e74c3c",
          weight = 1.5,
          fillColor = "lightcoral",
          fillOpacity = 0.25,  # Plus transparent pour ne pas masquer les autres couches
          label = paste("Zone d'acc√®s", input$buffer_dist, "km")
        ) %>%
        addLayersControl(
          overlayGroups = c("H√¥pitaux", "Localit√©s", "Zones de tampon", "R√©gions administratives"),  # M√™me ordre
          options = layersControlOptions(collapsed = FALSE)
        )
    }
  })
  
  # Filtrage des localit√©s
  observe({
    localites_filtrees <- place_enriched %>%
      filter(`Type de localit√©` %in% input$fclass_select)
    
    palette_localites <- colorFactor(
      viridis_pal(option = "C")(length(fclass_display)),
      domain = fclass_display
    )
    
    localite_labels <- sprintf(
      "<strong>%s %s</strong><br/> Type : %s<br> H√¥pital le plus proche : %s<br> Distance : %s km",
      case_when(
        localites_filtrees$`Type de localit√©` == "national_capital" ~ "üèõÔ∏è",
        localites_filtrees$`Type de localit√©` == "city" ~ "üèôÔ∏è",
        localites_filtrees$`Type de localit√©` == "town" ~ "üèòÔ∏è",
        localites_filtrees$`Type de localit√©` == "village" ~ "üè°",
        TRUE ~ "üè†"
      ),
      localites_filtrees$Nom,
      case_when(
        localites_filtrees$`Type de localit√©` == "national_capital" ~ "Capitale Nationale",
        localites_filtrees$`Type de localit√©` == "city" ~ "Ville",
        localites_filtrees$`Type de localit√©` == "town" ~ "Bourg",
        localites_filtrees$`Type de localit√©` == "village" ~ "Village",
        localites_filtrees$`Type de localit√©` == "hamlet" ~ "Hameau",
        localites_filtrees$`Type de localit√©` == "suburb" ~ "Banlieue",
        localites_filtrees$`Type de localit√©` == "locality" ~ "Localit√©",
        TRUE ~ localites_filtrees$`Type de localit√©`
      ),
      localites_filtrees$`H√¥pital le plus proche`,
      localites_filtrees$`Distance (km)`
    ) %>% lapply(htmltools::HTML)
    
    leafletProxy("interactive_map") %>%
      clearGroup("Localit√©s") %>%
      addCircleMarkers(
        data = localites_filtrees,
        group = "Localit√©s",
        color = ~palette_localites(`Type de localit√©`),
        fillColor = ~palette_localites(`Type de localit√©`),
        fillOpacity = 0.9,
        radius = ~case_when(
          `Type de localit√©` == "national_capital" ~ 8,
          `Type de localit√©` == "city" ~ 6,
          TRUE ~ 5
        ),
        stroke = TRUE,
        weight = ~case_when(
          `Type de localit√©` == "national_capital" ~ 3,
          TRUE ~ 1
        ),
        label = localite_labels,
        layerId = ~place_id,
        popup = ~paste(
          "<div style='max-width: 300px;'>",
          "<h4 style='color: #2c3e50;'>",
          case_when(
            `Type de localit√©` == "national_capital" ~ "üèõÔ∏è",
            `Type de localit√©` == "city" ~ "üèôÔ∏è",
            `Type de localit√©` == "town" ~ "üèòÔ∏è",
            `Type de localit√©` == "village" ~ "üè°",
            TRUE ~ "üè†"
          ),
          Nom, "</h4>",
          "<hr style='margin: 5px 0;'>",
          "<strong>üìã Type:</strong> ", 
          case_when(
            `Type de localit√©` == "national_capital" ~ "Capitale Nationale",
            `Type de localit√©` == "city" ~ "Ville",
            `Type de localit√©` == "town" ~ "Bourg",
            `Type de localit√©` == "village" ~ "Village",
            `Type de localit√©` == "hamlet" ~ "Hameau",
            `Type de localit√©` == "suburb" ~ "Banlieue",
            `Type de localit√©` == "locality" ~ "Localit√©",
            TRUE ~ `Type de localit√©`
          ), "<br>",
          "<strong> H√¥pital le plus proche :</strong> ", `H√¥pital le plus proche`, "<br>",
          "<strong> Distance :</strong> ", `Distance (km)`, " km",
          "</div>"
        )
      )
  })
  
  # Gestion des clics sur les marqueurs (H√îPITAUX)
  observeEvent(input$interactive_map_marker_click, {
    click_data <- input$interactive_map_marker_click
    
    if (!is.null(click_data$id)) {
      cat("Clic sur marqueur, ID:", click_data$id, "\n")
      
      # V√©rifier si c'est un h√¥pital
      if (click_data$id %in% hopital_enriched$unique_id) {
        rv_analysis$clicked_hospital_id <- click_data$id
        rv_analysis$clicked_place_id <- NULL
        rv_analysis$clicked_region <- NULL
        cat("‚úì H√¥pital cliqu√©:", click_data$id, "\n")
      } 
      # V√©rifier si c'est une localit√©
      else if (click_data$id %in% place_enriched$place_id) {
        rv_analysis$clicked_place_id <- click_data$id
        rv_analysis$clicked_hospital_id <- NULL
        rv_analysis$clicked_region <- NULL
      }
    }
  })
  
  # Gestion des clics sur les polygones (r√©gions)
  observeEvent(input$interactive_map_shape_click, {
    click_data <- input$interactive_map_shape_click
    
    if (!is.null(click_data$id) && click_data$id %in% regions_interactives$R√©gion) {
      rv_analysis$clicked_region <- click_data$id
      rv_analysis$clicked_hospital_id <- NULL
      rv_analysis$clicked_place_id <- NULL
    }
  })
  
  # Gestion des clics sur la carte (espaces vides)
  observeEvent(input$interactive_map_click, {
    click_data <- input$interactive_map_click
    
    # R√©initialiser les autres s√©lections
    rv_analysis$clicked_hospital_id <- NULL
    rv_analysis$clicked_place_id <- NULL
    rv_analysis$clicked_region <- NULL
    
    # V√©rifier si le clic est sur une r√©gion
    if (!is.null(click_data)) {
      click_point <- st_sf(
        geometry = st_sfc(st_point(c(click_data$lng, click_data$lat)), crs = CRS_WGS84)
      )
      
      # Trouver la r√©gion correspondante
      regions_intersected <- st_intersects(click_point, regions_interactives)
      
      if (length(regions_intersected[[1]]) > 0) {
        region_index <- regions_intersected[[1]][1]
        rv_analysis$clicked_region <- regions_interactives$R√©gion[region_index]
      } else {
        rv_analysis$region_data <- "Aucune information r√©gionale disponible pour cette zone.\nCliquez sur une r√©gion color√©e pour obtenir des informations."
      }
    }
  })
  
  # Analyse du clic sur un h√¥pital
  observeEvent(rv_analysis$clicked_hospital_id, {
    hospital_unique_id <- rv_analysis$clicked_hospital_id
    
    if (is.null(hospital_unique_id) || hospital_unique_id == "") return()
    
    clicked_hopital <- hopital_enriched %>%
      filter(unique_id == hospital_unique_id)
    
    if (nrow(clicked_hopital) == 0) return()
    
    dist_m <- input$buffer_dist * 1000
    
    if (dist_m > 0) {
      buffer_clicked <- st_buffer(clicked_hopital, dist = dist_m)
      
      # Extraction de la population dans le buffer
      cat("Extraction de la population dans le buffer...\n")
      total_pop_in_buffer <- extract_population(buffer_clicked)
      cat("Population dans le buffer:", total_pop_in_buffer, "\n")
      
      # Comptage des localit√©s par type (dans le tampon uniquement)
      localities_in_buffer <- st_filter(place_enriched, buffer_clicked, 
                                        .predicate = st_intersects)
      
      locality_counts <- localities_in_buffer %>%
        st_drop_geometry() %>%
        group_by(`Type de localit√©`) %>%
        tally(name = "Count") %>%
        arrange(desc(Count))
      
      locality_text <- if (nrow(locality_counts) > 0) {
        paste(sapply(1:nrow(locality_counts), function(i) {
          paste("  ‚Ä¢ ", 
                case_when(
                  locality_counts$`Type de localit√©`[i] == "national_capital" ~ "Capitale Nationale",
                  locality_counts$`Type de localit√©`[i] == "city" ~ "Ville",
                  locality_counts$`Type de localit√©`[i] == "town" ~ "Bourg",
                  locality_counts$`Type de localit√©`[i] == "village" ~ "Village",
                  locality_counts$`Type de localit√©`[i] == "hamlet" ~ "Hameau",
                  locality_counts$`Type de localit√©`[i] == "suburb" ~ "Banlieue",
                  locality_counts$`Type de localit√©`[i] == "locality" ~ "Localit√©",
                  TRUE ~ locality_counts$`Type de localit√©`[i]
                ),
                ": ", locality_counts$Count[i])
        }), collapse = "\n")
      } else {
        "  Aucune localit√© trouv√©e dans le tampon."
      }
      
      # Calcul du nombre total de localit√©s
      total_localities <- sum(locality_counts$Count, na.rm = TRUE)
      
      rv_analysis$hospital_data <- sprintf(
        "H√îPITAL S√âLECTIONN√â : %s\n Distance de tampon : %d km\n%s\n POPULATION COUVERTE :\n%s habitants\n%s\nÔ∏è LOCALIT√âS COUVERTES :\nTotal : %d localit√©(s)\n%s\n D√©tail par type :\n%s\n%s\nÔ∏è INFORMATIONS R√âGIONALES :\n R√©gion : %s\n Population r√©gionale : %s habitants\n H√¥pitaux dans la r√©gion : %s\n%s\n Conseil : Ajustez la distance du tampon pour modifier la zone d'analyse.",
        clicked_hopital$Nom_Hopital,
        input$buffer_dist,
        strrep("=", 50),
        format(round(total_pop_in_buffer), big.mark = " ", scientific = FALSE),
        strrep("=", 50),
        total_localities,
        strrep("-", 30),
        locality_text,
        strrep("=", 50),
        ifelse(is.na(clicked_hopital$R√©gion), "Non sp√©cifi√©", clicked_hopital$R√©gion),
        format(round(clicked_hopital$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
        clicked_hopital$`Nombre d'h√¥pitaux dans la r√©gion`,
        strrep("=", 50)
      )
    } else {
      rv_analysis$hospital_data <- sprintf(
        "H√îPITAL S√âLECTIONN√â : %s\n Distance de Tampon : 0 km\n%s\n Augmentez la distance du tampon pour effectuer l'analyse.\n%s\n INFORMATIONS R√âGIONALES :\n R√©gion : %s\n Population r√©gionale : %s habitants\n H√¥pitaux dans la r√©gion : %s\n%s\n Conseil : Augmentez la distance du tampon pour analyser la couverture.",
        clicked_hopital$Nom_Hopital,
        strrep("-", 50),
        strrep("=", 50),
        ifelse(is.na(clicked_hopital$R√©gion), "Non sp√©cifi√©", clicked_hopital$R√©gion),
        format(round(clicked_hopital$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
        clicked_hopital$`Nombre d'h√¥pitaux dans la r√©gion`,
        strrep("=", 50)
      )
    }
  })
  
  # Analyse du clic sur une localit√©
  observeEvent(rv_analysis$clicked_place_id, {
    place_id_clicked <- rv_analysis$clicked_place_id
    
    if (is.null(place_id_clicked) || place_id_clicked == "") return()
    
    clicked_place <- place_enriched %>%
      filter(place_id == place_id_clicked)
    
    if (nrow(clicked_place) > 0) {
      rv_analysis$place_data <- sprintf(
        "LOCALIT√â S√âLECTIONN√âE : %s\n Type : %s\n%s\n H√¥pital le plus proche : %s\n Distance : %s km\n%s\n Conseil : Cette distance repr√©sente le trajet √† vol d'oiseau jusqu'√† l'h√¥pital le plus proche.",
        clicked_place$Nom,
        case_when(
          clicked_place$`Type de localit√©` == "national_capital" ~ "Capitale Nationale",
          clicked_place$`Type de localit√©` == "city" ~ "Ville",
          clicked_place$`Type de localit√©` == "town" ~ "Bourg",
          clicked_place$`Type de localit√©` == "village" ~ "Village",
          clicked_place$`Type de localit√©` == "hamlet" ~ "Hameau",
          clicked_place$`Type de localit√©` == "suburb" ~ "Banlieue",
          clicked_place$`Type de localit√©` == "locality" ~ "Localit√©",
          TRUE ~ clicked_place$`Type de localit√©`
        ),
        strrep("-", 40),
        clicked_place$`H√¥pital le plus proche`,
        clicked_place$`Distance (km)`,
        strrep("=", 40)
      )
    }
  })
  
  # Analyse du clic sur une r√©gion
  observeEvent(rv_analysis$clicked_region, {
    region_name <- rv_analysis$clicked_region
    
    if (!is.null(region_name)) {
      region_info <- regions_interactives %>%
        filter(R√©gion == region_name) %>%
        st_drop_geometry()
      
      if (nrow(region_info) > 0) {
        rv_analysis$region_data <- sprintf(
          " R√âGION S√âLECTIONN√âE : %s\n%s\n Population : %s habitants\n Nombre d'h√¥pitaux : %s\n%s\n Conseil : Cliquez sur un h√¥pital pour analyser sa couverture avec le tampon actuel de %d km.",
          region_info$R√©gion,
          strrep("=", 40),
          format(round(region_info$`Population de la r√©gion`), big.mark = " ", scientific = FALSE),
          region_info$`Nombre d'h√¥pitaux dans la r√©gion`,
          strrep("=", 40),
          input$buffer_dist
        )
      }
    }
  })
  
  # Sorties textuelles
  output$hospital_analysis <- renderPrint({
    cat(rv_analysis$hospital_data)
  })
  
  output$place_analysis <- renderPrint({
    cat(rv_analysis$place_data)
  })
  
  output$region_analysis <- renderPrint({
    cat(rv_analysis$region_data)
  })
}

# ====================================================================
# LANCEMENT DE L'APPLICATION
# ====================================================================

shinyApp(ui = ui, server = server)

